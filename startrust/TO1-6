$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
$ rustup update
$ rustup self uninstall
$ rustc --version
rustc main.rs  

$ cargo --version
$ cargo new hello_cargo
$ cd hello_cargo
注意：Git 是一个常用的版本控制系统（version control system， VCS）。可以通过 --vcs 参数使 cargo new 切换到其它版本控制系统，或者不使用 VCS。运行 cargo new --help 查看可用的选项。
构建与运行：
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
$ ./target/debug/hello_cargo # 或者在 Windows 下为 .\target\debug\hello_cargo.exe
Hello, world!
我们刚刚使用 cargo build 构建了项目，并使用 ./target/debug/hello_cargo 运行了程序，但是，我们也可以使用 cargo run 命令，一次性完成代码编译和运行的操作

Cargo 还提供了一个名为 cargo check 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件：
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs


let apples = 5; // 不可变
let mut bananas = 5; // 可变

io::stdin()
        .read_line(&mut guess)
引用默认是不可变的。因此，需要写成 &mut guess 来使其可变，而不是 &guess



生成并查看项目使用了的依赖的使用文档：
注意：你不可能凭空就知道应该 use 哪个 trait 以及该从 crate 中调用哪个方法，所以每个 crate 都有使用说明文档。Cargo 有一个很棒的功能是：运行 cargo doc --open 命令来构建所有本地依赖提供的文档，并在浏览器中打开。例如，假设你对 rand crate 中的其他功能感兴趣，你可以运行 cargo doc --open 并点击左侧导航栏中的 rand。
当你确实需要升级 crate 时，Cargo 提供了这样一个命令 update，它会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本。Cargo 接下来会把这些版本写入 Cargo.lock 文件。不过，Cargo 默认只会寻找大于或等于 0.8.3 而小于 0.9.0 的版本。如果 rand crate 发布了两个新版本，0.8.4 和 0.9.0，在运行 cargo update 时会出现如下内容：
$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4


遮蔽
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    let spaces = "   ";
    let spaces = spaces.len();

mut
    let mut spaces = "   ";
    spaces = spaces.len();


标量类型：
整形
浮点
布尔
字符

复合类型：
元组let x: (i32, f64, u8) = (500, 6.4, 1); 允许不同类型 let five_hundred = x.0;
数组let a = [1, 2, 3, 4, 5];类型必须相同  let a: [i32; 5] = [1, 2, 3, 4, 5];  let a = [3; 5]; let first = a[0];

function:
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}


语句和表达式
函数体由一系列语句组成，也可选择以表达式结尾
语句（statement）是执行一些操作但不返回值的指令。表达式（expression）计算并产生一个值

这个表达式：
{
    let x = 3;
    x + 1
}
是一个代码块，在这个例子中计算结果是 4。这个值作为 let 语句的一部分被绑定到 y 上。注意，x + 1 行的末尾没有分号，这与你目前见过的大部分代码行不同。表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。在接下来探讨函数返回值和表达式时，请记住这一点。

返回值
fn five() -> i32 {
    5
}

if 后直接接上表达式 且表达式返回的必须是布尔类型
if number < 5 {
	println!("condition was true");
} else {
	println!("condition was false");
}
let number = if condition { 5 } else { 6 };尤其注意：rust是静态类型语言，所以在这里的 if else中不管哪个分支，返回的类型必须相同


loop
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }
for
    for element in a {
        println!("the value is: {}", element);
    }
    for number in (1..4).rev() {
        println!("{}!", number);
    }`
while





Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。
栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。
在堆上分配大量的空间也可能消耗时间。
当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。
跟踪哪部分代码正在使用堆上的哪些数据，最大限度地减少堆上的重复数据量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。


所有权规则
首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则:
Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
值在任一时刻有且只有一个所有者。
当所有者（变量）离开作用域，这个值将被丢弃。

移动
克隆

Rust 有一个叫做 Copy trait 的特殊标注，可以用在类似整型这样的存储在栈上的类型上（第 10 章详细讲解 trait）。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 标注，将会出现一个编译时错误。要学习如何为你的类型添加 Copy 标注以实现该 trait，请阅读附录 C 中的 “可派生的 trait”。

那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：

所有整数类型，比如 u32。
布尔类型，bool，它的值是 true 和 false。
所有浮点数类型，比如 f64。
字符类型，char。
元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。

将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。
返回值也可以转移所有权

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

借用与引用
可变引用与不可变引用 无法同时有多个可变引用，且可变引用与不可变引用不能同时存在，且存在不可变引用时无法通过原变量修改数据， 注意：注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。不可变引用不能同时存在，且存在不可变引用时无法通过原变量修改数据， 注意：一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。


fn main() {
    let reference_to_nothing = dangle();
}
fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
注意：上面的代码刻意产生一个悬垂指针，会触发编译错误，就这个例子来讲， 所有权可以从主函数中到函数再回到主函数，但是不能直接从函数到主函数



切片

字符串字面量就是 slice
还记得我们讲到过字符串字面量被储存在二进制文件中吗？现在知道 slice 了，我们就可以正确地理解字符串字面量了：
let s = "Hello, world!";
这里 s 的类型是 &str：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面量是不可变的；&str 是一个不可变引用。

注意：str String &str 的区别
fn first_word(s: &str) -> &str {

str 字符串它是 DST 动态大小类型，这意味着编译器无法在编译期知道 str 类型的大小，只有到了运行期才能动态获知，这对于强类型、强安全的 Rust 语言来说是不可接受的。
let string: str = "banana";
上面代码创建一个 str 类型的字符串，看起来很正常，但是编译就会报错
let string: &str = "banana";  // 正确：引用有固定大小

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
// 注意这里的写法
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..]
}
//数组切片
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];



结构体：
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
如果要修改结构体实例，注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。另外需要注意同其他任何表达式一样，我们可以在函数体的最后一个表达式中构造一个结构体的新实例，来隐式地返回这个实例。


上述例子使用了自身拥有所有权的 String 类型而不是 &str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。
可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上生命周期（lifetime）

结构体更新语法：
如：
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
请注意，结构更新语法就像带有 = 的赋值，因为它移动了数据，就像我们在“变量与数据交互的方式（一）：移动”部分讲到的一样。在这个例子中，我们在创建 user2 后不能再使用 user1，因为 user1 的 username 字段中的 String 被移到 user2 中。如果我们给 user2 的 email 和 username 都赋予新的 String 值，从而只使用 user1 的 active 和 sign_in_count 值，那么 user1 在创建 user2 后仍然有效。active 和 sign_in_count 的类型是实现 Copy trait 的类型，所以我们在“变量与数据交互的方式（二）：克隆”部分讨论的行为同样适用。

元组结构体：
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
struct AlwaysEqual; 定义了一个单元结构体（unit struct），它没有任何字段，用处暂时不知道

添加外部属性 #[derive(Debug)]后可以使用以下形式的println! 来打印出调试信息
Debug 是 Rust 标准库中的一个 trait，用于以调试友好的格式输出类型的值
或者使用 dbg!宏
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
println!("rect1 is {:?}", rect1);
dbg!(&rect1);
dbg!还可以这样用：
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    }; 会输出：[src/main.rs:10] 30 * scale = 60

为rectangle结构体定义一个area方法
impl Rectangle {
    fn area(&self) -> u32 { 第一个参数必须是Self类型的参数，如self:&Self &self是其缩写 
    这种写法是不可变引用， 当然也可以写 &mut self来获得可变引用
        self.width * self.height
    }
}
调用：rect1.area()

（p1.distance(&p2) 和 (&p1).distance(&p2)）功能完全一致，区别仅在于是否显式写出接收器的引用（前者依赖 Rust 的自动引用特性，更简洁）。
第三种写法（p1.distance(&p1)）是用自身作为参数调用方法，只要方法允许（即参数为不可变引用），就是合法的，语义上表示 “计算自身与自身的距离”

关联函数经常被用作返回一个结构体新实例的构造函数。例如我们可以提供一个关联函数，它接受一个维度参数并且同时作为宽和高，这样可以更轻松的创建一个正方形 Rectangle 而不必指定两次同样的值：
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
使用结构体名和 :: 语法来调用这个关联函数：比如 let sq = Rectangle::square(3)
如String::from() 


构造函数中，若参数名与字段名完全相同则可以使用字段初始化简写语法，如关联函数build_user,返回一个新的user结构体实例：
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}





枚举：
enum IpAddrKind {
    V4,
    V6,
}
枚举可以直接携带数据
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
如果要使用这些数据，需要使用match 或者 if let



enum Message {
    Quit,
}
struct QuitMessage; // 类单元结构体 注意这quit与quitmessage的区别



枚举和结构体还有另一个相似点：就像可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法。这是我们在 Message 枚举上定义了一个叫做 call 的方法：
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
impl Message {
    fn call(&self) {
        // 在这里定义方法体
    }
}



option枚举，定义在标准库中，可以理解为只是为使用者提供了一种现成可用的枚举类型，它可以是任意值或者是空值
enum Option<T> {
    Some(T),
    None,
}
使用时：
let some_number = Some(5);
let some_string = Some("a string");

let absent_number: Option<i32> = None;// 由于泛型T的存在，空值需要指定类型
None不同于 enum IpAddrKind {
    V4,
    V6,
} 中的V4,V6,需要指定类型

下面代码报错：编译器不允许像一个肯定有效的值那样使用 Option<T>
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
编译器会确保我们在使用值之前处理了为空的情况。
换句话说，在对 Option<T> 进行 T 的运算之前必须将其转换为 T。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。
不再担心会错误地假设一个非空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式地将其放入对应类型的 Option<T> 中。接着，当使用这个值时，必须明确地处理值为空的情况。只要一个值不是 Option<T> 类型，你就 可以 安全地认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。



match
Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。match 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。
示例： Coin为枚举类型，
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
} 

对于option枚举：
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            Some(i) => Some(i + 1),
        }
    }
这无法通过编译，因为没有match没有考虑到None的情况
Rust 知道我们没有覆盖所有可能的情况甚至知道哪些模式被忘记了！Rust 中的匹配是穷举式的（exhaustive）：必须穷举到最后的可能性来使代码有效。
让我们看一个例子，我们希望对一些特定的值采取特殊操作，而对其他的值采取默认操作
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        /* other => move_player(other), */
         _ => reroll(), // _与other二选一 other仍然会将匹配到的值绑定到other上，而_不会，它告诉编译器不使用匹配到的值，不需要绑定，这样Rust 也不会警告我们存在未使用的变量。    }


if let 
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) => println!("three"),
    _ => (),
}

if let Some(3) = some_u8_value {
    println!("three");
}


if let可以配合else使用：
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
相当于：
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
