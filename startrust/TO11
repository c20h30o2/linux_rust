如何编写测试
Rust 中的测试函数是用来验证非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：
设置任何所需的数据或状态
运行需要测试的代码
断言其结果是我们所期望的
让我们看看 Rust 提供的专门用来编写测试的功能：test 属性、一些宏和 should_panic 属性。

单元测试（Unit Tests）
  放在源文件底部的 tests 模块中（最常见）下面的简单例子就是一个单元测试：
  // src/lib.rs 或 src/some_module.rs
  特点：
  - 使用 #[cfg(test)] 只在测试时编译
  - 可以测试私有函数
  - 与被测代码在同一文件
示例：
作为最简单例子，Rust 中的测试就是一个带有 test 属性标注的函数。属性（attribute）是关于 Rust 代码片段的元数据；第 5 章中结构体中用到的 derive 属性就是一个例子。为了将一个函数变成测试函数，需要在 fn 行之前加上 #[test]。当使用 cargo test 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 test 属性的函数，并报告每一个测试是通过还是失败。
文件名: src/lib.rs
fn main() {}
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
现在让我们暂时忽略 tests 模块和 #[cfg(test)] 标注，并只关注函数来了解其如何工作。注意 fn 行之前的 #[test]：这个属性表明这是一个测试函数，这样测试执行者就知道将其作为测试处理。因为也可以在 tests 模块中拥有非测试的函数来帮助我们建立通用场景或进行常见操作，所以需要使用 #[test] 属性标明哪些函数是测试。
可以认为执行cargo test时，编译器会为 #[test]的函数分别拉起一个线程进行测试，
> cargo test会为每一个#[test]标注的函数分别拉起一个线程来运行他们，对吗
● 是的，基本正确！但有一些细节需要补充：
  默认并行行为
  cargo test 默认会并行运行测试，每个 #[test] 函数在独立的线程中执行。

  具体机制
  1. 线程池模式
    - 不是每个测试一个新线程，而是使用线程池
    - 默认线程数 = CPU 核心数
  2. 并行执行
  #[test]
  fn test_1() { /* 可能在线程 A */ }
  #[test]
  fn test_2() { /* 可能在线程 B */ }
  #[test]
  fn test_3() { /* 可能在线程 C */ }

  控制测试并行度
  # 串行运行（单线程）
  cargo test -- --test-threads=1
  # 指定线程数
  cargo test -- --test-threads=4
  # 查看默认线程数
  cargo test -- --show-output


cargo test 命令会运行项目中所有的测试，如示例 11-2 所示：
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out



使用 assert_eq! 和 assert_ne! 宏来测试相等
测试功能的一个常用方法是将需要测试代码的值与期望值做比较，并检查是否相等。可以通过向 assert! 宏传递一个使用 == 运算符的表达式来做到。不过这个操作实在是太常见了，以至于标准库提供了一对宏来更方便的处理这些操作 —— assert_eq! 和 assert_ne!。这两个宏分别比较两个值是相等还是不相等。当断言失败时他们也会打印出这两个值具体是什么，以便于观察测试 为什么 失败，而 assert! 只会打印出它从 == 表达式中得到了 false 值，而不是导致 false 的两个值。
assert_eq! 和 assert_ne! 宏在底层分别使用了 == 和 !=。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必需实现了 PartialEq 和 Debug trait。所有的基本类型和大部分标准库类型都实现了这些 trait。对于自定义的结构体和枚举，需要实现 PartialEq 才能断言他们的值是否相等。需要实现 Debug 才能在断言失败时打印他们的值。因为这两个 trait 都是派生 trait，如第 5 章示例 5-12 所提到的，通常可以直接在结构体或枚举上添加 #[derive(PartialEq, Debug)] 标注。附录 C “可派生的 trait” 中有更多关于这些和其他派生 trait 的详细信息。


自定义失败信息
你也可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。任何在 assert! 的一个必需参数和 assert_eq! 和 assert_ne! 的两个必需参数之后指定的参数都会传递给 format! 宏（在第 8 章的 “使用 + 运算符或 format! 宏拼接字符串” 部分讨论过），所以可以传递一个包含 {} 占位符的格式字符串和需要放入占位符的值。自定义信息有助于记录断言的意义；当测试失败时就能更好的理解代码出了什么问题。
#[test]
fn greeting_contains_name() {
    let result = greeting("Carol");
    assert!(
        result.contains("Carol"),
        "Greeting did not contain name, value was `{}`", result
    );
}




使用 should_panic 检查 panic
除了检查代码是否返回期望的正确的值之外，检查代码是否按照期望处理错误也是很重要的。例如，考虑第 9 章示例 9-10 创建的 Guess 类型。其他使用 Guess 的代码都是基于 Guess 实例仅有的值范围在 1 到 100 的前提。可以编写一个测试来确保创建一个超出范围的值的 Guess 实例会 panic。
可以通过对函数增加另一个属性 should_panic 来实现这些。这个属性在函数中的代码 panic 时会通过，而在其中的代码没有 panic 时失败。
fn main() {}
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#[should_panic] 属性位于 #[test] 之后，对应的测试函数之前,如果测试函数确实panic,则通过测试，否则就说明函数在该panic时没有panic,所以测试不通过

当有多种可能导致panic时，我们希望是确定的原因导致的panic：
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!("Guess value must be greater than or equal to 1, got {}.",
                   value);
        } else if value > 100 {
            panic!("Guess value must be less than or equal to 100, got {}.",
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
这样，只有当触发的时else if中的panic时，才通过测试



将 Result<T, E> 用于测试
目前为止，我们编写的测试在失败时就会 panic。也可以使用 Result<T, E> 编写测试！下面是一个将示例 11-1 重写以使用 Result<T, E> 并返回一个 Err 而不是直接 panic 的测试：
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}
现在 it_works 函数的返回值类型为 Result<(), String>。在函数体中，不同于调用 assert_eq! 宏，而是在测试通过时返回 Ok(())，在测试失败时返回带有 String 的 Err。




控制测试如何运行
就像 cargo run 会编译代码并运行生成的二进制文件一样，cargo test 在测试模式下编译代码并运行生成的测试二进制文件。可以指定命令行参数来改变 cargo test 的默认行为。例如，cargo test 生成的二进制文件的默认行为是并行的运行所有测试，并截获测试运行过程中产生的输出，阻止他们被显示出来，使得阅读测试结果相关的内容变得更容易。

可以将一部分命令行参数传递给 cargo test，而将另外一部分传递给生成的测试二进制文件。为了分隔这两种参数，需要先列出传递给 cargo test 的参数，接着是分隔符 --，再之后是传递给测试二进制文件的参数。运行 cargo test --help 会提示 cargo test 的有关参数，而运行 cargo test -- --help 可以提示在分隔符 -- 之后使用的有关参数。

cargo test -- --test-threads=1
这里将测试线程设置为 1，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。

默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。
如果你希望也能看到通过的测试中打印的值，可以通过在末尾增加 --show-output 参数来告知 Rust 显示通过测试的输出：
$ cargo test -- --show-output

通过指定名字来运行部分测试
有时运行整个测试集会耗费很长时间。如果你负责特定位置的代码，你可能会希望只运行与这些代码相关的测试。你可以向 cargo test 传递所希望运行的测试名称的参数来选择运行哪些测试。
运行单个测试
可以向 cargo test 传递任意测试的名称来只运行这个测试：
$ cargo test one_hundred

过滤运行多个测试
我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 add，可以通过 cargo test add 来运行这两个测试

忽略某些测试
有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 cargo test 的时候希望能排除他们。虽然可以通过参数列举出所有希望运行的测试来做到，也可以使用 ignore 属性来标记耗时的测试并排除他们
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}
#[test]
#[ignore]
fn expensive_test() {
    // 需要运行一个小时的代码
}

通过控制运行哪些测试，你可以确保能够快速地运行 cargo test 。当你需要运行 ignored 的测试时，可以执行 cargo test -- --ignored。


rust的测试分为单元测试、集成测试、文档测试，之前的示例中都是单元测试
单元测试
单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，以便于快速而准确的某个单元的代码功能是否符合预期。单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 tests 模块，并使用 cfg(test) 标注模块。
测试模块和 #[cfg(test)]
测试模块的 #[cfg(test)] 标注告诉 Rust 只在执行 cargo test 时才编译和运行测试代码，而在运行 cargo build 时不这么做。这在只希望构建库的时候可以节省编译时间，并且因为它们并没有包含测试，所以能减少编译产生的文件的大小。与之对应的集成测试因为位于另一个文件夹，所以它们并不需要 #[cfg(test)] 标注。然而单元测试位于与源码相同的文件中，所以你需要使用 #[cfg(test)] 来指定他们不应该被包含进编译结果中。
rust允许测试私有函数

集成测试
Rust 的集成测试（Integration Testing）是用于测试 crate 公共 API 整体功能的测试方式，关注多个模块或组件协同工作的正确性，而非单个函数或结构体的细节（后者属于单元测试）。集成测试通常在独立的 tests 目录中编写，完全模拟外部用户使用 crate 的场景。
在 Rust 中，集成测试对于你需要测试的库来说完全是外部的。同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以集成测试的覆盖率也是很重要的。为了创建集成测试，你需要先创建一个 tests 目录。
文件名: tests/integration_test.rs
use adder;
#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
示例 11-13：一个 adder crate 中函数的集成测试
与单元测试不同，我们需要在文件顶部添加 use adder。这是因为每一个 tests 目录中的测试文件都是完全独立的 crate，所以需要在每一个文件中导入库。
并不需要将 tests/integration_test.rs 中的任何代码标注为 #[cfg(test)]。 tests 文件夹在 Cargo 中是一个特殊的文件夹， Cargo 只会在运行 cargo test 时编译这个目录中的文件。
我们仍然可以通过指定测试函数的名称作为 cargo test 的参数来运行特定集成测试。也可以使用 cargo test 的 --test 后跟文件的名称来运行某个特定集成测试文件中的所有测试


