包和crate
包中所包含的内容由几条规则来确立。一个包中至多 只能 包含一个库 crate（library crate）；包中可以包含任意多个二进制 crate（binary crate）；包中至少包含一个 crate，无论是库的还是二进制的。
如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：一个库和一个二进制项，且名字都与包相同。通过将文件放在 src/bin 目录下，一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate。
目录结构如：
my_project/          # 项目根目录（即“包”的根）
├── Cargo.toml       # 包的配置文件（定义包名、版本、依赖等）
├── Cargo.lock       # 依赖版本锁定文件（自动生成）
├── src/             # 源代码目录
│   ├── lib.rs       # 库 crate 的入口文件（整个包唯一的库crate）
│   ├── main.rs      # 默认二进制 crate 的入口文件（名为 my_project 的二进制）
│   └── bin/         # 其他二进制 crate 的目录（可放任意多个）
│       ├── tool1.rs # 二进制 crate 1（编译后生成 tool1 可执行文件）
│       └── tool2.rs # 二进制 crate 2（编译后生成 tool2 可执行文件）
└── tests/           # 库 crate 的集成测试目录（可选）
    └── integration_test.rs

我们可以将函数放置到嵌套的模块中，来使我们的 crate 结构与实际的餐厅结构相同。通过执行 cargo new --lib restaurant，来创建一个新的名为 restaurant 的库。然后将示例 7-1 中所罗列出来的代码放入 src/lib.rs 中，来定义一些模块和函数。

文件名: src/lib.rs
#![allow(unused)]
fn main() {
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
之前我们提到，src/main.rs 和 src/lib.rs 被称为 crate 根。如此称呼的原因是，这两个文件中任意一个的内容会构成名为 crate 的模块，且该模块位于 crate 的被称为 模块树 的模块结构的根部（"at the root of the crate’s module structure"）。
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment

文件名: src/lib.rs   这两个pub少一个都会导致编译不通过
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
pub fn eat_at_restaurant() {
    // 绝对路径
    crate::front_of_house::hosting::add_to_waitlist();

    // 相对路径
    front_of_house::hosting::add_to_waitlist();
}// 至于到底是选择用绝对路径还是相对路径，可以根据需要选择，一般多选绝对路径
模块上的 pub 关键字只允许其父模块引用它。
在绝对路径，我们从 crate，也就是 crate 根部开始。然后 crate 根部中定义了 front_of_house 模块。front_of_house 模块不是公有的，不过因为 eat_at_restaurant 函数与 front_of_house 定义于同一模块中（即，eat_at_restaurant 和 front_of_house 是兄弟），我们可以从 eat_at_restaurant 中引用 front_of_house。接下来是使用 pub 标记的 hosting 模块。我们可以访问 hosting 的父模块，所以可以访问 hosting。最后，add_to_waitlist 函数被标记为 pub ，我们可以访问其父模块，所以这个函数调用是有效的！
在相对路径，其逻辑与绝对路径相同，除了第一步：不同于从 crate 根部开始，路径从 front_of_house 开始。front_of_house 模块与 eat_at_restaurant 定义于同一模块，所以从 eat_at_restaurant 中开始定义的该模块相对路径是有效的。接下来因为 hosting 和 add_to_waitlist 被标记为 pub，路径其余的部分也是有效的，因此函数调用也是有效的！


文件名: src/lib.rs
fn serve_order() {}
mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}


结构体可以同时带有公有和私有字段：
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}
但枚举一旦公有，则所有成员都变为公有mod back_of_house 
{
    pub enum Appetizer {
        Soup,
        Salad,
    }
}


使用use关键字将名称引入作用域：
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;// 使用绝对路径引入
// use front_of_house::hosting; // 使用相对路径引入
// use crate::front_of_house::hosting::add_to_waitlist;// 直接引入add to wait list函数，虽然这样引入后，要使用时可以直接使用，但一般习惯上不这么做，而是只引入到父模块为止，用 父模块::函数名 的方式调用,这样可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化。
// 例外，使用 use 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。
// 另外，当要引入两个具有相同名称但不同父模块的类型时，一般引入到父模块为止，以便区分`
pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
fn main() {}

使用as关键字提供新的名称 如：
use std::io::Result as IoResult;
如：
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
通过 pub use，现在可以通过新路径 hosting::add_to_waitlist 来调用 add_to_waitlist 函数。如果没有指定 pub use，eat_at_restaurant 函数可以在其作用域中调用 hosting::add_to_waitlist，但外部代码则不允许使用这个新路径。


嵌套路径写法：
use std::cmp::Ordering;
use std::io; 
简写成：use std::{cmp::Ordering, io};

use std::io;
use std::io::Write;
简写成：use std::io::{self, Write};

如果希望将一个路径下 所有 公有项引入作用域，可以指定路径后跟 glob 运算符 *：
use std::collections::*;
这个 use 语句将 std::collections 中定义的所有公有项引入当前作用域。使用 glob 运算符时请多加小心！Glob 会使得我们难以推导作用域中有什么名称和它们是在何处定义的。


将模块分割进不同文件
修改前： src/lib.rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}
pub use crate::front_of_house::hosting;
pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

修改后：
src/lib.rs:
mod front_of_house; // 在 mod front_of_house 后使用分号，而不是代码块，这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容
pub use crate::front_of_house::hosting;
pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

src/front_of_house.rs:
pub mod hosting; // 同理，告诉rust在hosting.rs中加载模块内容

src/front_of_house/hosting.rs:
pub fn add_to_waitlist() {}

模块树依然保持相同，eat_at_restaurant 中的函数调用也无需修改继续保持有效，即便其定义存在于不同的文件中。这个技巧让你可以在模块代码增长时，将它们移动到新文件中。

注意，src/lib.rs 中的 pub use crate::front_of_house::hosting 语句是没有改变的，在文件作为 crate 的一部分而编译时，use 不会有任何影响。mod 关键字声明了模块，Rust 会在与模块同名的文件中查找模块的代码。
