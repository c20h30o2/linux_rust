# 日志系统实现方案

**日期：** 2025-11-01
**需求：** 通过 `make run LOG=INFO` 控制日志输出等级

---

## 需求分析

### 期望效果

```bash
# 只显示 ERROR 级别
make run LOG=ERROR

# 显示 ERROR + WARN
make run LOG=WARN

# 显示 ERROR + WARN + INFO
make run LOG=INFO

# 显示所有日志（包括 DEBUG, TRACE）
make run LOG=TRACE
```

### 当前问题

```rust
// 现在的实现：所有宏都无条件输出
info!("...");   // 总是输出
debug!("...");  // 总是输出
trace!("...");  // 总是输出
```

---

## 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **方案 1：Cargo Features** | 编译期确定，零开销 | 改等级需重新编译 | **推荐** - 裸机 OS |
| **方案 2：环境变量 + build.rs** | 灵活，自动生成代码 | 改等级需重新编译 | 自动化构建 |
| **方案 3：运行时静态变量** | 运行时可改 | 有性能开销 | 需要动态调整 |
| **方案 4：编译期宏常量** | 简单，零开销 | 最不灵活 | 简单项目 |

---

## 方案 1：Cargo Features（推荐）

### 设计思路

**日志等级继承关系：**

```
TRACE ⊃ DEBUG ⊃ INFO ⊃ WARN ⊃ ERROR
```

- `LOG=ERROR` → 只启用 ERROR
- `LOG=WARN` → 启用 WARN + ERROR
- `LOG=INFO` → 启用 INFO + WARN + ERROR
- `LOG=DEBUG` → 启用 DEBUG + INFO + WARN + ERROR
- `LOG=TRACE` → 启用所有

### 实现步骤

#### 1. 修改 `Cargo.toml`

```toml
[package]
name = "os"
version = "0.1.0"
edition = "2021"

[dependencies]
sbi-rt = { version = "0.0.2", features = ["legacy"] }

[profile.release]
debug = true

# 日志等级 features
[features]
default = ["log-error"]           # 默认只显示错误

# 等级定义（每个等级包含更低等级）
log-error = []
log-warn = ["log-error"]
log-info = ["log-warn"]
log-debug = ["log-info"]
log-trace = ["log-debug"]
```

#### 2. 修改 `src/console.rs`

```rust
use crate::sbi::console_putchar;
use core::fmt::{self, Write};

struct Stdout;

impl Write for Stdout {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for c in s.chars() {
            console_putchar(c as usize);
        }
        Ok(())
    }
}

pub fn print(args: fmt::Arguments) {
    Stdout.write_fmt(args).unwrap();
}

// 基础 print 宏
#[macro_export]
macro_rules! print {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!($fmt $(, $($arg)+)?));
    }
}

#[macro_export]
macro_rules! println {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        $crate::console::print(format_args!(concat!($fmt, "\n") $(, $($arg)+)?));
    }
}

// 带条件编译的日志宏
#[macro_export]
macro_rules! error {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        // ERROR 总是启用（如果编译了 log-error feature）
        #[cfg(feature = "log-error")]
        $crate::console::print(format_args!(
            concat!("\x1b[31m[ERROR] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}

#[macro_export]
macro_rules! warn {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        #[cfg(feature = "log-warn")]
        $crate::console::print(format_args!(
            concat!("\x1b[93m[WARN] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}

#[macro_export]
macro_rules! info {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        #[cfg(feature = "log-info")]
        $crate::console::print(format_args!(
            concat!("\x1b[34m[INFO] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}

#[macro_export]
macro_rules! debug {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        #[cfg(feature = "log-debug")]
        $crate::console::print(format_args!(
            concat!("\x1b[32m[DEBUG] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}

#[macro_export]
macro_rules! trace {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        #[cfg(feature = "log-trace")]
        $crate::console::print(format_args!(
            concat!("\x1b[90m[TRACE] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}
```

#### 3. 创建 `Makefile`

```makefile
# rCore OS Makefile

# 默认目标架构
TARGET := riscv64gc-unknown-none-elf
MODE := release

# 日志等级（默认 ERROR）
LOG ?= ERROR

# 转换为小写的 feature 名称
LOG_FEATURE := log-$(shell echo $(LOG) | tr A-Z a-z)

# 路径配置
KERNEL_ELF := target/$(TARGET)/$(MODE)/os
KERNEL_BIN := $(KERNEL_ELF).bin
BOOTLOADER := ../bootloader/rustsbi-qemu.bin

# 编译器工具
OBJDUMP := rust-objdump
OBJCOPY := rust-objcopy

# QEMU 配置
QEMU := qemu-system-riscv64
QEMU_ARGS := -machine virt \
             -nographic \
             -bios $(BOOTLOADER) \
             -device loader,file=$(KERNEL_BIN),addr=0x80200000

# 默认目标
.PHONY: all
all: $(KERNEL_BIN)

# 编译内核
.PHONY: build
build:
	@echo "Building with LOG level: $(LOG)"
	@cargo build --release --features $(LOG_FEATURE)

# 生成二进制
$(KERNEL_BIN): build
	@echo "Generating binary image..."
	@$(OBJCOPY) --strip-all $(KERNEL_ELF) -O binary $@

# 运行
.PHONY: run
run: $(KERNEL_BIN)
	@echo "Running OS with LOG=$(LOG)..."
	@$(QEMU) $(QEMU_ARGS)

# 调试运行
.PHONY: debug
debug: $(KERNEL_BIN)
	@echo "Starting QEMU in debug mode (gdb server on :1234)..."
	@$(QEMU) $(QEMU_ARGS) -s -S

# GDB 连接
.PHONY: gdb
gdb:
	@gdb-multiarch -nh -x .gdbinit

# 反汇编
.PHONY: disasm
disasm: build
	@$(OBJDUMP) -d $(KERNEL_ELF) | less

# 查看符号表
.PHONY: nm
nm: build
	@rust-nm $(KERNEL_ELF) | sort

# 清理
.PHONY: clean
clean:
	@cargo clean
	@rm -f $(KERNEL_BIN)

# 帮助
.PHONY: help
help:
	@echo "rCore OS Build System"
	@echo ""
	@echo "Usage:"
	@echo "  make run              - Build and run (default LOG=ERROR)"
	@echo "  make run LOG=INFO     - Build and run with INFO level"
	@echo "  make run LOG=DEBUG    - Build and run with DEBUG level"
	@echo "  make run LOG=TRACE    - Build and run with TRACE level"
	@echo "  make debug            - Start QEMU with GDB server"
	@echo "  make gdb              - Connect GDB to QEMU"
	@echo "  make clean            - Clean build artifacts"
	@echo ""
	@echo "Available LOG levels:"
	@echo "  ERROR  - Only error messages"
	@echo "  WARN   - Error + Warning"
	@echo "  INFO   - Error + Warning + Info"
	@echo "  DEBUG  - Error + Warning + Info + Debug"
	@echo "  TRACE  - All messages"
```

#### 4. 测试代码（修改 `src/main.rs`）

```rust
#![no_std]
#![no_main]

#[macro_use]
mod console;
mod lang_items;
mod sbi;

use core::arch::global_asm;
global_asm!(include_str!("entry.asm"));

unsafe extern "C" {
    fn stext();
    fn etext();
    fn srodata();
    fn erodata();
    fn sdata();
    fn edata();
    fn sbss();
    fn ebss();
}

#[unsafe(no_mangle)]
pub fn rust_main() -> ! {
    clear_bss();

    // 测试不同等级的日志
    trace!("This is TRACE message");
    debug!("This is DEBUG message");
    info!("This is INFO message");
    warn!("This is WARN message");
    error!("This is ERROR message");

    // 打印内存布局（使用 INFO 等级）
    info!(".text   [{:#x}, {:#x})", stext as usize, etext as usize);
    info!(".rodata [{:#x}, {:#x})", srodata as usize, erodata as usize);
    info!(".data   [{:#x}, {:#x})", sdata as usize, edata as usize);
    info!(".bss    [{:#x}, {:#x})", sbss as usize, ebss as usize);

    panic!("Shutdown!");
}

fn clear_bss() {
    unsafe {
        (sbss as usize..ebss as usize).for_each(|a| {
            (a as *mut u8).write_volatile(0);
        });
    }
}
```

### 使用示例

```bash
# 只显示 ERROR
make run LOG=ERROR
# 输出：
# [ERROR] This is ERROR message
# Panicked at src/main.rs:xx Shutdown!

# 显示 WARN + ERROR
make run LOG=WARN
# 输出：
# [WARN] This is WARN message
# [ERROR] This is ERROR message
# Panicked at src/main.rs:xx Shutdown!

# 显示 INFO + WARN + ERROR
make run LOG=INFO
# 输出：
# [INFO] This is INFO message
# [INFO] .text   [0x80200000, 0x80201000)
# [INFO] .rodata [0x80202000, 0x80202567)
# [INFO] .data   [0x80203000, 0x80203100)
# [INFO] .bss    [0x80204000, 0x80210000)
# [WARN] This is WARN message
# [ERROR] This is ERROR message
# Panicked at src/main.rs:xx Shutdown!

# 显示所有日志
make run LOG=TRACE
# 输出所有 5 种等级的消息
```

---

## 方案 2：环境变量 + build.rs

### 优点
- 更灵活的配置
- 可以自动生成代码
- 支持更复杂的逻辑

### 实现

#### 1. 创建 `build.rs`

```rust
// build.rs
use std::env;

fn main() {
    // 读取环境变量
    let log_level = env::var("LOG_LEVEL").unwrap_or_else(|_| "ERROR".to_string());

    // 定义等级顺序
    let levels = ["ERROR", "WARN", "INFO", "DEBUG", "TRACE"];
    let current_index = levels.iter().position(|&l| l == log_level).unwrap_or(0);

    // 为每个等级设置 cfg
    for (i, level) in levels.iter().enumerate() {
        if i <= current_index {
            println!("cargo:rustc-cfg=log_level_{}", level.to_lowercase());
        }
    }

    // 重新运行的条件
    println!("cargo:rerun-if-env-changed=LOG_LEVEL");
}
```

#### 2. 修改 `console.rs` 宏定义

```rust
#[macro_export]
macro_rules! error {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        #[cfg(log_level_error)]
        $crate::console::print(format_args!(
            concat!("\x1b[31m[ERROR] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}

#[macro_export]
macro_rules! info {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        #[cfg(log_level_info)]
        $crate::console::print(format_args!(
            concat!("\x1b[34m[INFO] ", $fmt, "\x1b[0m\n")
            $(, $($arg)+)?
        ));
    }
}
// ... 其他宏类似
```

#### 3. 修改 `Makefile`

```makefile
LOG ?= ERROR

.PHONY: build
build:
	@echo "Building with LOG level: $(LOG)"
	@LOG_LEVEL=$(LOG) cargo build --release
```

---

## 方案 3：运行时配置（高级）

### 适用场景
- 需要在运行时动态调整日志等级
- 例如通过调试命令改变等级

### 实现

#### 1. 创建 `src/logging.rs`

```rust
// src/logging.rs
use core::sync::atomic::{AtomicU8, Ordering};

#[repr(u8)]
#[derive(Copy, Clone, PartialEq, PartialOrd)]
pub enum LogLevel {
    Error = 0,
    Warn = 1,
    Info = 2,
    Debug = 3,
    Trace = 4,
}

static LOG_LEVEL: AtomicU8 = AtomicU8::new(LogLevel::Error as u8);

pub fn set_log_level(level: LogLevel) {
    LOG_LEVEL.store(level as u8, Ordering::Relaxed);
}

pub fn get_log_level() -> LogLevel {
    match LOG_LEVEL.load(Ordering::Relaxed) {
        0 => LogLevel::Error,
        1 => LogLevel::Warn,
        2 => LogLevel::Info,
        3 => LogLevel::Debug,
        4 => LogLevel::Trace,
        _ => LogLevel::Error,
    }
}

pub fn should_log(level: LogLevel) -> bool {
    level <= get_log_level()
}
```

#### 2. 修改宏定义

```rust
#[macro_export]
macro_rules! info {
    ($fmt: literal $(, $($arg: tt)+)?) => {
        if $crate::logging::should_log($crate::logging::LogLevel::Info) {
            $crate::console::print(format_args!(
                concat!("\x1b[34m[INFO] ", $fmt, "\x1b[0m\n")
                $(, $($arg)+)?
            ));
        }
    }
}
```

#### 3. 初始化

```rust
// main.rs
pub fn rust_main() -> ! {
    clear_bss();

    // 设置日志等级（可以从配置读取）
    #[cfg(feature = "log-info")]
    logging::set_log_level(logging::LogLevel::Info);

    info!("Log level set to INFO");
    // ...
}
```

---

## 推荐配置

### 最终推荐：方案 1（Cargo Features）

**理由：**
1. ✅ 编译期优化 - 零运行时开销
2. ✅ 简单易用 - `make run LOG=INFO`
3. ✅ 代码干净 - 不需要额外逻辑
4. ✅ 适合裸机 - 没有复杂依赖

### 目录结构

```
os/
├── Makefile              ← 新增
├── Cargo.toml            ← 修改（添加 features）
├── .cargo/
│   └── config.toml
├── src/
│   ├── main.rs           ← 修改（测试日志）
│   ├── console.rs        ← 修改（添加条件编译）
│   ├── entry.asm
│   ├── lang_items.rs
│   └── sbi.rs
└── ...
```

### 编译输出对比

**LOG=ERROR：**
```
   Compiling os v0.1.0
    Features: log-error
```

**LOG=INFO：**
```
   Compiling os v0.1.0
    Features: log-error, log-warn, log-info
```

**LOG=TRACE：**
```
   Compiling os v0.1.0
    Features: log-error, log-warn, log-info, log-debug, log-trace
```

---

## 常见问题

### Q1: 为什么要用 features 而不是运行时变量？

**A:** 裸机环境特点：
- 没有命令行参数
- 没有环境变量
- 没有文件系统
- 编译期确定可以优化掉不需要的代码

### Q2: 如何快速切换等级？

```bash
# 开发时用 DEBUG
make run LOG=DEBUG

# 测试时用 INFO
make run LOG=INFO

# 发布时用 ERROR
make run LOG=ERROR
```

### Q3: features 的继承关系是怎么工作的？

```toml
log-info = ["log-warn"]  # info 包含 warn
log-warn = ["log-error"] # warn 包含 error
```

编译时：
- 启用 `log-info` → 自动启用 `log-warn` → 自动启用 `log-error`

### Q4: 如何在代码中检查当前日志等级？

```rust
#[cfg(feature = "log-debug")]
fn some_debug_only_function() {
    // 只在 DEBUG 等级时编译
}
```

---

## 总结

| 方案 | 适用场景 | 复杂度 | 性能 |
|------|---------|--------|------|
| **Cargo Features** | ✅ **裸机 OS（推荐）** | 低 | 最优 |
| **build.rs** | 自动化构建 | 中 | 优 |
| **运行时** | 需要动态调整 | 高 | 中 |

**立即开始：**
1. 修改 `Cargo.toml` - 添加 features
2. 修改 `console.rs` - 添加条件编译
3. 创建 `Makefile` - 支持 LOG 参数
4. 测试：`make run LOG=INFO`

---

## 下一步

实现方案 1 后，可以考虑的增强：
1. 添加时间戳（如果有时钟）
2. 添加文件名和行号
3. 添加模块过滤
4. 添加日志缓冲区

详细实现见后续文档。
