# 链接脚本符号的引入机制详解

**日期：** 2025-11-01
**核心问题：** 为什么需要用 `fn stext()` 引入链接脚本符号？这是如何工作的？

---

## 问题描述

在 Rust 代码中，我们这样引入链接脚本符号：

```rust
unsafe extern "C" {
    fn stext();      // ← 为什么是函数？
    fn etext();
}

// 使用时
info!(".text [{:#x}, {:#x})", stext as usize, etext as usize);
//                             ^^^^^^^^^^^^^^
//                             转换为地址
```

**疑问：**
1. 为什么声明为 `fn stext()` 而不是 `static stext: u8`？
2. 为什么 `as usize` 就能得到地址？
3. 链接器是如何处理的？

---

## 链接脚本中的符号本质

### linker.ld 中的定义

```ld
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80200000;

SECTIONS {
    . = BASE_ADDRESS;

    stext = .;              ← 创建一个符号，值是当前地址
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    etext = .;              ← 创建符号，值是 .text 段结束地址

    . = ALIGN(4K);
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
    }
    erodata = .;
}
```

### 符号的本质

**关键理解：**

```
stext = .;
```

**这行代码做了什么？**
1. 创建一个名为 `stext` 的**符号**（symbol）
2. 这个符号的**值**就是当前的链接地址（`.` 代表当前位置计数器）
3. **符号不是变量**，它不占用任何内存空间
4. 符号只是一个**地址标记**

**类比理解：**

```
符号 ≈ 书签
- 书签标记了书的某一页（地址）
- 书签本身不是书的内容（不是数据）
- 你通过书签能找到那一页（获取地址）
```

---

## 符号 vs 变量

### C/C++ 中的对比

**定义一个变量：**
```c
// C 代码
int value = 42;        // 这是一个变量
//  ^^^^^ 在内存中有 4 字节存储 42

// 内存布局：
// 地址      内容
// 0x1000:  0x0000002A  (42 的十六进制)
```

**链接脚本中的符号：**
```ld
/* linker.ld */
stext = 0x80200000;    // 这是一个符号
//      ^^^^^^^^^^^ 符号的值（地址）

// 符号表：
// 名称     值（地址）
// stext    0x80200000
//
// 注意：0x80200000 处可能没有数据！
// 这只是一个地址标记
```

---

## 为什么不能用变量声明？

### 错误方式 1：声明为变量

```rust
// ❌ 错误：声明为静态变量
unsafe extern "C" {
    static stext: u8;
}

fn rust_main() -> ! {
    unsafe {
        println!("stext = {}", stext);  // ← 会尝试读取该地址的值！
        //                     ^^^^^
        //                     Rust 认为这是一个变量，会去读内存
    }
}
```

**问题：**

```
1. Rust 认为 stext 是一个真实存在的 u8 变量
2. 访问 stext 会尝试读取 0x80200000 处的 1 字节
3. 但我们想要的是地址本身（0x80200000），不是该地址的内容！
```

**会发生什么：**

```rust
// 假设 0x80200000 处的实际内容是：0x93
static stext: u8;

println!("{}", stext);        // 输出：147 (0x93)
//             ^^^^^ 读取了地址 0x80200000 的内容

// 但我们想要：
println!("{:#x}", ???);       // 想输出：0x80200000（地址本身）
```

### 错误方式 2：试图获取变量地址

```rust
// ❌ 仍然错误
unsafe extern "C" {
    static stext: u8;
}

fn rust_main() -> ! {
    unsafe {
        let addr = &stext as *const u8 as usize;  // 能得到地址
        println!("addr = {:#x}", addr);           // 但很别扭
    }
}
```

**问题：**
1. 需要额外的 `&` 操作
2. 语义不清晰（stext 不是真正的变量）
3. 可能引起误用（有人可能直接读 `stext` 的值）

---

## 正确方式：声明为函数

### 为什么用函数？

```rust
// ✅ 正确：声明为函数
unsafe extern "C" {
    fn stext();
    fn etext();
}

fn rust_main() -> ! {
    let text_start = stext as usize;    // 直接转换为地址
    let text_end = etext as usize;

    println!(".text [{:#x}, {:#x})", text_start, text_end);
}
```

**优点：**

1. **永远不会调用函数**
   ```rust
   stext();  // 没人会这样写，因为明显不合理
   ```

2. **函数名本身就代表地址**
   ```rust
   stext as usize  // 直接得到函数地址（= 符号地址）
   ```

3. **语义清晰**
   ```rust
   // 看到函数声明，就知道这是一个地址标记
   // 不会误以为是可以读写的变量
   ```

4. **类型安全**
   ```rust
   // 类型系统防止你错误使用
   let x = stext;        // 错误：需要显式转换
   let x = stext as usize;  // 正确：明确转换为地址
   ```

---

## 底层工作原理

### 链接过程

```
┌──────────────────────────────────────────────────┐
│ 1. 编译 Rust 代码                                  │
├──────────────────────────────────────────────────┤
│ Rust 编译器看到：                                  │
│   extern "C" { fn stext(); }                     │
│                                                  │
│ 生成：                                             │
│   - 对符号 "stext" 的未定义引用（undefined ref）   │
│   - 不生成任何函数代码（因为是 extern）             │
└──────────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────────┐
│ 2. 链接阶段（ld）                                  │
├──────────────────────────────────────────────────┤
│ 链接器任务：                                        │
│   - 查找所有未定义的符号                            │
│   - 从链接脚本中找到 stext = .;                    │
│   - 计算 stext 的地址（假设是 0x80200000）         │
│   - 将符号 "stext" 的地址填入符号表                │
└──────────────────────────────────────────────────┘
                    ↓
┌──────────────────────────────────────────────────┐
│ 3. 最终 ELF 文件                                   │
├──────────────────────────────────────────────────┤
│ 符号表：                                           │
│   名称      类型      地址                         │
│   stext    NOTYPE   0x80200000                   │
│   etext    NOTYPE   0x80201234                   │
│   rust_main FUNC    0x80200384                   │
└──────────────────────────────────────────────────┘
```

### 运行时行为

**Rust 代码：**
```rust
let addr = stext as usize;
```

**编译后的汇编（伪代码）：**
```asm
# stext as usize
la a0, stext        # 加载 stext 的地址到 a0
# a0 现在包含 0x80200000
```

**实际汇编（RISC-V）：**
```asm
# 假设 stext = 0x80200000
lui  a0, 0x80200    # 加载高 20 位：0x80200
addi a0, a0, 0      # 加载低 12 位：0x000
# a0 = 0x80200000
```

**关键点：**
- **不会跳转**到 stext（因为没有 `call` 或 `jalr`）
- **只是加载地址**到寄存器

---

## 实际验证

### 查看符号表

```bash
$ rust-nm target/riscv64gc-unknown-none-elf/release/os | grep text
0000000080200000 T stext
0000000080201000 T etext
```

**解读：**
- `T` 表示符号类型（Text section symbol）
- `0000000080200000` 就是符号的值（地址）
- 没有大小信息（因为不是变量）

### 查看 Rust 代码生成的汇编

```rust
// Rust 代码
let addr = stext as usize;
```

**反汇编：**
```bash
$ rust-objdump -d target/riscv64gc-unknown-none-elf/release/os

rust_main:
  ...
  802003a0: 37 05 20 80   lui a0, 0x80200    # 加载 stext 地址高位
  802003a4: 13 05 05 00   mv  a5, a0          # 复制到 a5
  ...
```

**证明：**
- 只是加载地址，没有调用函数
- 没有 `call` 或 `jalr` 指令

---

## 类型转换详解

### `stext as usize` 发生了什么？

```rust
fn stext();  // 类型：fn()

let ptr = stext;           // 类型：fn()（函数指针）
let addr = stext as usize; // 类型：usize（地址的整数表示）
```

**步骤：**

```
1. stext               → fn() 类型（函数指针）
   ↓
2. 函数指针的值        → 函数的地址（编译器知道）
   ↓
3. as usize            → 转换为整数
   ↓
4. 0x80200000          → 地址的数值表示
```

**类型系统视角：**

```rust
// 类型推导
stext           : fn()          // 函数类型
stext as usize  : usize         // 地址类型

// 等价的 C 代码
void (*stext)();                // 函数指针
uintptr_t addr = (uintptr_t)stext;  // 转换为整数
```

---

## 其他语言的对比

### C 语言

```c
// C 代码
extern char stext[];  // 常见做法：声明为数组

void print_text_range(void) {
    printf(".text [%p, %p)\n", stext, etext);
    //                         ^^^^^^ 数组名自动转换为地址
}
```

**为什么 C 用数组？**
- C 中数组名在大多数上下文中会退化为指针
- `stext` 直接就是地址，不需要 `&`

**Rust 为什么不用数组？**
```rust
// Rust 中
extern "C" {
    static stext: [u8; 0];  // 零大小数组？
}

let addr = &stext as *const _ as usize;  // 需要 &，很别扭
```

- Rust 的数组不会自动退化为指针
- 需要显式取地址，语义不清晰

---

### C++ 的做法

```cpp
// C++ 代码
extern "C" char stext;  // 声明为 char

void print_text_range() {
    std::cout << ".text ["
              << (void*)&stext    // 取地址
              << ", "
              << (void*)&etext
              << ")\n";
}
```

**问题：**
- 需要 `&` 操作符
- 容易误用（直接访问 `stext` 的值）

---

## 完整示例

### linker.ld

```ld
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80200000;

SECTIONS {
    . = BASE_ADDRESS;

    stext = .;                    /* 符号：.text 开始 */
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    . = ALIGN(4K);
    etext = .;                    /* 符号：.text 结束 */

    srodata = .;                  /* 符号：.rodata 开始 */
    .rodata : {
        *(.rodata .rodata.*)
    }
    . = ALIGN(4K);
    erodata = .;                  /* 符号：.rodata 结束 */

    sdata = .;
    .data : {
        *(.data .data.*)
    }
    . = ALIGN(4K);
    edata = .;

    sbss = .;
    .bss : {
        *(.bss.stack)
        *(.bss .bss.*)
    }
    . = ALIGN(4K);
    ebss = .;
}
```

### main.rs

```rust
#![no_std]
#![no_main]

// 声明链接脚本符号
unsafe extern "C" {
    fn stext();     // .text 段开始
    fn etext();     // .text 段结束
    fn srodata();   // .rodata 段开始
    fn erodata();   // .rodata 段结束
    fn sdata();     // .data 段开始
    fn edata();     // .data 段结束
    fn sbss();      // .bss 段开始
    fn ebss();      // .bss 段结束
}

#[no_mangle]
pub fn rust_main() -> ! {
    clear_bss();

    // 打印内存布局
    info!(".text   [{:#x}, {:#x})", stext as usize, etext as usize);
    info!(".rodata [{:#x}, {:#x})", srodata as usize, erodata as usize);
    info!(".data   [{:#x}, {:#x})", sdata as usize, edata as usize);
    info!(".bss    [{:#x}, {:#x})", sbss as usize, ebss as usize);

    loop {}
}

fn clear_bss() {
    unsafe {
        // 同样的模式：获取地址范围
        let start = sbss as usize;
        let end = ebss as usize;

        (start..end).for_each(|addr| {
            (addr as *mut u8).write_volatile(0);
        });
    }
}
```

### 预期输出

```
[INFO].text   [0x80200000, 0x80201000)
[INFO].rodata [0x80202000, 0x80202567)
[INFO].data   [0x80203000, 0x80203100)
[INFO].bss    [0x80204000, 0x80210000)
```

---

## 常见问题

### Q1: 能不能直接调用 stext()？

**A:** 技术上可以，但会崩溃：

```rust
unsafe {
    stext();  // ← 会跳转到 0x80200000 执行
}

// 0x80200000 处是代码段开始，可能是：
// 0x80200000: auipc sp, 0x10  ← 这不是一个函数！
// 会执行一些随机指令，然后崩溃
```

**为什么？**
- `stext` 不是真正的函数
- 只是一个地址标记
- 该地址处的指令不是一个完整的函数

---

### Q2: 为什么 clear_bss 也用同样的模式？

```rust
fn clear_bss() {
    unsafe extern "C" {
        fn sbss();
        fn ebss();
    }
    (sbss as usize..ebss as usize).for_each(|a| {
        (a as *mut u8).write_volatile(0);
    });
}
```

**A:** 完全相同的原理：

```
sbss, ebss 是链接脚本符号
  ↓
声明为函数（地址标记）
  ↓
转换为 usize（地址值）
  ↓
创建地址范围遍历
  ↓
清零每个字节
```

---

### Q3: 能用裸指针吗？

**可以，但更复杂：**

```rust
// 方案 A：使用函数（推荐）
extern "C" {
    fn stext();
}
let addr = stext as usize;

// 方案 B：使用裸指针（不推荐）
extern "C" {
    static stext: u8;
}
let addr = &stext as *const u8 as usize;
```

**对比：**
- 方案 A：清晰、简洁
- 方案 B：需要 `&`、`*const`、两次转换

---

### Q4: 能用常量吗？

**不能：**

```rust
// ❌ 错误：常量必须在编译期已知
const STEXT: usize = 0x80200000;  // 硬编码，不灵活

// ✅ 正确：通过链接脚本动态确定
extern "C" {
    fn stext();
}
```

**原因：**
- 链接脚本的符号地址在**链接期**确定
- 不是编译期常量
- 需要通过符号引用

---

## 总结

### 核心原理

| 概念 | 解释 |
|------|------|
| **链接脚本符号** | 地址标记，不是变量 |
| **符号的值** | 就是地址本身 |
| **声明为函数** | 获取地址，不会调用 |
| **`as usize`** | 函数地址 → 整数地址 |

### 为什么用函数

| 原因 | 说明 |
|------|------|
| **语义清晰** | 明确表示这是地址标记 |
| **防止误用** | 不会有人去调用函数 |
| **类型安全** | 需要显式转换 |
| **简洁** | 直接 `as usize`，无需 `&` |

### 工作流程

```
链接脚本定义符号
    ↓
  stext = .;   (地址：0x80200000)
    ↓
Rust 声明函数
    ↓
  fn stext();
    ↓
链接器解析
    ↓
  stext → 0x80200000
    ↓
代码中使用
    ↓
  stext as usize  → 0x80200000
```

---

## 实践建议

### 推荐模式

```rust
// ✅ 推荐：集中声明
unsafe extern "C" {
    // .text 段
    fn stext();
    fn etext();
    // .rodata 段
    fn srodata();
    fn erodata();
    // .data 段
    fn sdata();
    fn edata();
    // .bss 段
    fn sbss();
    fn ebss();
}

// ✅ 推荐：辅助函数
pub fn print_memory_layout() {
    info!(".text   [{:#x}, {:#x})", stext as usize, etext as usize);
    info!(".rodata [{:#x}, {:#x})", srodata as usize, erodata as usize);
    info!(".data   [{:#x}, {:#x})", sdata as usize, edata as usize);
    info!(".bss    [{:#x}, {:#x})", sbss as usize, ebss as usize);
}
```

### 避免的模式

```rust
// ❌ 不推荐：声明为变量
extern "C" {
    static stext: u8;  // 容易误用
}

// ❌ 不推荐：硬编码地址
const STEXT: usize = 0x80200000;  // 不灵活

// ❌ 不推荐：每次都声明
fn foo() {
    extern "C" { fn stext(); }  // 重复声明
}
```

---

**关键记忆：** 链接脚本符号是**地址标记**，不是变量。用函数声明可以安全、清晰地获取地址。

---

## 参考资料

- [Rust FFI 文档](https://doc.rust-lang.org/nomicon/ffi.html)
- [Linker Scripts (LD)](https://sourceware.org/binutils/docs/ld/Scripts.html)
- [rCore Tutorial Book](https://rcore-os.cn/rCore-Tutorial-Book-v3/)
