# 函数调用与栈帧详解

**日期：** 2025-11-01
**核心问题：** 函数开头的 `addi sp, sp, -16` 是什么？栈帧里放什么？

---

## 问题描述

查看函数反汇编时，经常看到这样的模式：

```asm
rust_main:
    addi sp, sp, -32      # ← 为什么减 32？
    sd   ra, 24(sp)       # ← 存什么？
    sd   s0, 16(sp)       # ← 为什么存这些寄存器？
    ...
    # 函数体
    ...
    ld   ra, 24(sp)       # ← 恢复
    ld   s0, 16(sp)
    addi sp, sp, 32       # ← 恢复栈指针
    ret
```

**疑问：**
1. 为什么要 `sp = sp - 32`？
2. 栈帧里存放什么？
3. 为什么是这些寄存器？
4. 为什么是 32 字节？

---

## 栈帧的本质

### 什么是栈帧（Stack Frame）？

**栈帧 = 函数的私有内存空间**

```
栈帧用途：
1. 保存调用者的状态（返回地址、寄存器）
2. 存储局部变量
3. 传递超出寄存器数量的参数
4. 为调用其他函数准备参数空间
```

### 栈的增长方向

**RISC-V（和大多数架构）：栈向下增长**

```
高地址  ┌─────────────────┐
        │                 │
        │  调用者的栈帧    │
        │                 │
        ├─────────────────┤ ← sp（进入函数前）
        │                 │
        │  当前函数栈帧    │ ← 新分配的空间
        │                 │
        ├─────────────────┤ ← sp（进入函数后）
        │                 │
        │  被调用者栈帧    │
        │                 │
低地址  └─────────────────┘

sp 减小 = 分配栈空间
sp 增大 = 释放栈空间
```

---

## 栈帧里放什么？

### 典型栈帧结构

```
高地址
        ┌─────────────────────────────────┐
        │ 调用者的栈帧                      │
        ├─────────────────────────────────┤ ← 进入函数前的 sp
sp+24 → │ 返回地址 (ra)                    │ ← 保存的寄存器
sp+16 → │ 保存的 s0 (frame pointer)        │
sp+8  → │ 保存的 s1                        │
sp+0  → │ 局部变量 / 临时空间               │ ← 当前 sp
        ├─────────────────────────────────┤
        │ 被调用函数的参数 / 栈帧           │
低地址  └─────────────────────────────────┘
```

### 栈帧内容详解

| 内容 | 说明 | 何时需要 |
|------|------|---------|
| **返回地址 (ra)** | 函数返回后的下一条指令地址 | 调用其他函数时必须保存 |
| **被调用者保存寄存器 (s0-s11)** | 调用者期望保持不变的寄存器 | 函数使用这些寄存器时 |
| **局部变量** | 函数内定义的变量 | 变量太多放不进寄存器 |
| **临时空间** | 中间计算结果 | 寄存器不够用时 |
| **参数溢出区** | 超过 8 个参数的部分 | 参数 > 8 个时 |

---

## RISC-V 调用约定（Calling Convention）

### 寄存器分类

RISC-V 有 32 个通用寄存器，分为不同类别：

| 寄存器 | ABI 名称 | 用途 | 调用时是否保存 |
|-------|---------|------|--------------|
| **x0** | `zero` | 硬编码为 0 | - |
| **x1** | `ra` | 返回地址 | **调用者保存** |
| **x2** | `sp` | 栈指针 | **被调用者保存** |
| **x3** | `gp` | 全局指针 | - |
| **x4** | `tp` | 线程指针 | - |
| **x5-x7** | `t0-t2` | 临时寄存器 | **调用者保存** |
| **x8** | `s0/fp` | 保存寄存器/帧指针 | **被调用者保存** |
| **x9** | `s1` | 保存寄存器 | **被调用者保存** |
| **x10-x11** | `a0-a1` | 参数/返回值 | **调用者保存** |
| **x12-x17** | `a2-a7` | 参数 | **调用者保存** |
| **x18-x27** | `s2-s11` | 保存寄存器 | **被调用者保存** |
| **x28-x31** | `t3-t6` | 临时寄存器 | **调用者保存** |

### 两种保存策略

**1. 调用者保存（Caller-saved）**
```
调用者在调用函数前保存（如果需要保留值）
包括：ra, t0-t6, a0-a7
```

**2. 被调用者保存（Callee-saved）**
```
被调用函数必须保证这些寄存器调用前后值不变
包括：sp, s0-s11
```

---

## 实际例子分析

### 例子 1：简单函数（不调用其他函数）

**Rust 代码：**
```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

**汇编：**
```asm
add:
    # 无栈帧分配！
    add a0, a0, a1    # a0 = a0 + a1（参数在 a0, a1）
    ret               # 返回（返回值在 a0）
```

**分析：**
- 不需要栈帧（叶子函数，leaf function）
- 不调用其他函数 → 不需要保存 `ra`
- 不使用 s 寄存器 → 不需要保存
- 结果直接在寄存器中 → 不需要局部变量空间

---

### 例子 2：调用其他函数

**Rust 代码：**
```rust
fn foo() {
    bar();    // 调用其他函数
}
```

**汇编：**
```asm
foo:
    addi sp, sp, -16      # 分配 16 字节栈帧
    sd   ra, 8(sp)        # 保存返回地址

    call bar              # 调用 bar（会修改 ra）

    ld   ra, 8(sp)        # 恢复返回地址
    addi sp, sp, 16       # 释放栈帧
    ret                   # 返回
```

**为什么要保存 ra？**

```
执行流程：
1. main 调用 foo
   ra = main 中 foo() 的下一条指令地址

2. foo 内部调用 bar
   call bar → ra = foo 中 bar() 的下一条指令地址
   ↑ 问题：原来的 ra 被覆盖了！

3. bar 返回后，如果没有保存 ra
   ret → 跳转到 foo 内部，而不是 main！
   ❌ 错误！
```

**正确流程（保存 ra）：**

```
1. foo 入口：
   保存 ra 到栈：[ra_main]

2. call bar：
   ra = ra_foo（bar 的返回地址）

3. bar 返回：
   ret → 回到 foo

4. foo 返回前：
   从栈恢复 ra：ra = ra_main
   ret → 正确回到 main
```

---

### 例子 3：使用局部变量

**Rust 代码：**
```rust
fn calculate() -> i32 {
    let a = 10;
    let b = 20;
    let c = 30;
    // 假设寄存器不够用
    a + b + c
}
```

**汇编（简化）：**
```asm
calculate:
    addi sp, sp, -16      # 分配栈帧

    li   t0, 10           # a = 10
    sd   t0, 0(sp)        # 存到栈上

    li   t0, 20           # b = 20
    sd   t0, 8(sp)        # 存到栈上

    li   a0, 30           # c = 30（用寄存器）

    ld   t0, 0(sp)        # 加载 a
    add  a0, a0, t0
    ld   t0, 8(sp)        # 加载 b
    add  a0, a0, t0       # 结果在 a0

    addi sp, sp, 16       # 释放栈帧
    ret
```

---

### 例子 4：rust_main 实际分析

**反汇编 rust_main：**
```bash
$ rust-objdump -d target/riscv64gc-unknown-none-elf/release/os
```

```asm
0000000080200384 <rust_main>:
 80200384: 1141           addi    sp,sp,-16          # 分配 16 字节
 80200386: e406           sd      ra,8(sp)           # 保存 ra（调用其他函数）
 80200388: e022           sd      s0,0(sp)           # 保存 s0（可能用作帧指针）
 8020038a: 0800           addi    s0,sp,16           # s0 = 原 sp（帧指针）

 8020038c: 00000097       auipc   ra,0x0             # 准备调用 clear_bss
 80200390: 06c080e7       jalr    108(ra)            # call clear_bss

 # ... 其他函数调用（println, info, panic 等）

 802003ec: 60a2           ld      ra,8(sp)           # 恢复 ra
 802003ee: 6402           ld      s0,0(sp)           # 恢复 s0
 802003f0: 0141           addi    sp,sp,16           # 释放栈帧
 802003f2: 8082           ret                        # 返回
```

**栈帧布局：**

```
进入 rust_main 前：
sp → ┌─────────────────┐
     │  调用者栈帧      │
     └─────────────────┘

执行 addi sp,sp,-16 后：
     ┌─────────────────┐ ← 原 sp (s0)
     │                 │
sp+8 │ 保存的 ra       │ ← entry.asm 的返回地址
sp+0 │ 保存的 s0       │
     ├─────────────────┤ ← 当前 sp
```

**为什么是 16 字节？**

```
需要保存的内容：
1. ra (8 字节)
2. s0 (8 字节)
─────────────
总计：16 字节
```

---

## 栈帧大小计算

### 编译器如何决定栈帧大小？

```
栈帧大小 = 最大（以下各项对齐后的和）

1. 需要保存的寄存器
   - ra（如果调用其他函数）：8 字节
   - s0-s11（如果使用）：每个 8 字节

2. 局部变量
   - 不能放在寄存器中的变量

3. 临时空间
   - 复杂表达式的中间结果

4. 参数传递区
   - 调用函数时参数 > 8 个的部分

5. 对齐要求
   - RISC-V 要求 16 字节对齐（ABI 规范）
```

### 实例计算

**情况 1：只保存 ra**
```
需要：8 字节（ra）
对齐：16 字节
→ 栈帧大小：16 字节
```

**情况 2：保存 ra + s0 + s1**
```
需要：8 + 8 + 8 = 24 字节
对齐：32 字节（向上对齐到 16 的倍数）
→ 栈帧大小：32 字节
```

**情况 3：保存 ra + 两个局部变量**
```
需要：8 + 8 + 8 = 24 字节
对齐：32 字节
→ 栈帧大小：32 字节
```

---

## 帧指针（Frame Pointer）

### s0/fp 的特殊作用

有些函数会使用 **帧指针（fp，即 s0）**：

```asm
rust_main:
    addi sp, sp, -32
    sd   ra, 24(sp)
    sd   s0, 16(sp)
    addi s0, sp, 32       # ← s0 = 原 sp（帧指针）

    # 现在可以用 s0 访问栈帧：
    # s0-8  = 返回地址
    # s0-16 = 保存的 s0
    ...
```

**为什么需要帧指针？**

| 场景 | 说明 |
|------|------|
| **调试** | GDB 可以通过 fp 遍历调用栈 |
| **动态栈帧** | 栈帧大小在运行时变化（如 alloca）|
| **代码可读性** | 访问局部变量更清晰 |

**使用 sp vs fp：**

```asm
# 使用 sp（栈帧固定）
ld a0, 8(sp)       # sp 可能在函数中变化

# 使用 fp（栈帧固定）
ld a0, -16(s0)     # s0 固定指向栈帧顶部，不变
```

---

## 完整调用流程示例

### 代码

```rust
fn main() {
    foo(1, 2);
}

fn foo(a: i32, b: i32) -> i32 {
    bar(a + b)
}

fn bar(x: i32) -> i32 {
    x * 2
}
```

### 调用栈演变

**1. 初始状态（main）**

```
sp → ┌─────────────────┐
     │ main 的栈帧     │
     └─────────────────┘
```

**2. 调用 foo(1, 2)**

```
     ┌─────────────────┐
     │ main 的栈帧     │
     ├─────────────────┤ ← 原 sp
sp+8 │ ra (返回到main) │
sp+0 │ s0 (如果使用)   │
     ├─────────────────┤ ← sp
     │ (foo 的工作空间) │
```

**3. foo 调用 bar(3)**

```
     ┌─────────────────┐
     │ main 的栈帧     │
     ├─────────────────┤
     │ foo 的栈帧      │
     ├─────────────────┤ ← foo 的 sp
sp+8 │ ra (返回到foo)  │
sp+0 │ s0              │
     ├─────────────────┤ ← sp
     │ (bar 的工作空间) │
```

**4. bar 返回**

```
清理 bar 的栈帧：
sp = sp + 16

     ┌─────────────────┐
     │ main 的栈帧     │
     ├─────────────────┤
     │ foo 的栈帧      │
     ├─────────────────┤ ← sp 回到这里
```

**5. foo 返回**

```
清理 foo 的栈帧：
sp = sp + 16

sp → ┌─────────────────┐
     │ main 的栈帧     │
     └─────────────────┘ ← 回到初始状态
```

---

## 实际调试观察

### 使用 GDB 查看栈帧

```gdb
(gdb) break rust_main
(gdb) continue

Breakpoint 1, rust_main () at src/main.rs:72
72      pub fn rust_main() -> ! {

(gdb) info registers sp
sp             0x80220000

(gdb) stepi                     # 执行 addi sp,sp,-16
(gdb) info registers sp
sp             0x8021fff0        # ← sp 减少了 16 (0x10)

(gdb) x/2gx $sp                 # 查看栈上内容
0x8021fff0:     0x0000000000000000  0x0000000080200008
                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^
                保存的 s0            保存的 ra

(gdb) backtrace
#0  rust_main () at src/main.rs:72
#1  0x0000000080200008 in _start () at src/entry.asm:5
```

---

## 优化与特殊情况

### 优化级别的影响

**Debug 模式（`--debug`）：**
```asm
# 总是分配栈帧，保存寄存器
rust_main:
    addi sp, sp, -32
    sd   ra, 24(sp)
    sd   s0, 16(sp)
    ...
```

**Release 模式（`--release`）：**
```asm
# 可能内联小函数，消除栈帧
rust_main:
    # 直接内联 clear_bss 的代码
    # 不需要栈帧
    ...
```

### 尾调用优化（Tail Call Optimization）

**未优化：**
```asm
foo:
    ...
    call bar      # 调用 bar
    ret           # bar 返回后再返回
```

**尾调用优化：**
```asm
foo:
    ...
    j bar         # 直接跳转到 bar，让 bar 直接返回给调用者
    # 不需要保存 ra！
```

---

## 栈溢出（Stack Overflow）

### 什么时候发生？

```rust
// 递归太深
fn factorial(n: u64) -> u64 {
    if n <= 1 { 1 } else { n * factorial(n - 1) }
}

factorial(100000);  // ← 栈溢出！
```

**每次递归：**
- 分配新栈帧（如 16 字节）
- 递归 100000 次 = 1.6 MB
- 超过栈大小（如 64 KB）→ **栈溢出**

### 栈溢出的后果

```
栈向下增长超过了分配的空间：

  boot_stack_lower_bound
  ↓
  ┌─────────────────┐ ← 栈的底部
  │                 │
  │  栈空间 (64KB)  │
  │                 │
  ├─────────────────┤ ← sp 正常范围
  │  溢出区域       │ ← sp 如果到这里
  ├─────────────────┤
  │  其他数据/代码  │ ← 可能被覆盖！
  └─────────────────┘
```

**后果：**
- 覆盖其他内存
- 程序崩溃
- 数据损坏

---

## 总结

### 栈帧的作用

| 用途 | 说明 | 示例 |
|------|------|------|
| **保存返回地址** | 允许正确返回 | `sd ra, 8(sp)` |
| **保存寄存器** | 遵守调用约定 | `sd s0, 0(sp)` |
| **局部变量** | 存储临时数据 | 数组、结构体 |
| **参数传递** | 超过 8 个参数 | 第 9+ 个参数 |

### 关键操作

```asm
# 函数入口
addi sp, sp, -16      # 分配栈帧
sd   ra, 8(sp)        # 保存返回地址
sd   s0, 0(sp)        # 保存寄存器

# 函数体
...

# 函数返回
ld   ra, 8(sp)        # 恢复返回地址
ld   s0, 0(sp)        # 恢复寄存器
addi sp, sp, 16       # 释放栈帧
ret                   # 返回
```

### 栈帧大小

```
栈帧大小 = (需要保存的内容 + 局部变量 + 临时空间) 向上对齐到 16 字节
```

### 调用约定记忆

```
调用者保存（Caller-saved）：
  - ra, t0-t6, a0-a7
  - 如果需要保留值，调用前自己保存

被调用者保存（Callee-saved）：
  - sp, s0-s11
  - 函数必须保证调用前后值不变
```

---

## 实践建议

### 调试栈问题

```gdb
# 查看栈指针
info registers sp

# 查看调用栈
backtrace

# 查看栈上的内容
x/16gx $sp

# 查看帧指针
info registers s0
```

### 避免栈溢出

```rust
// ❌ 避免深度递归
fn bad(n: u64) -> u64 {
    if n == 0 { 0 } else { bad(n-1) + 1 }
}

// ✅ 使用迭代
fn good(n: u64) -> u64 {
    let mut sum = 0;
    for i in 0..=n { sum += 1; }
    sum
}
```

---

**核心记忆：** 函数入口的 `addi sp, sp, -N` 是在分配栈帧，用于保存**返回地址**、**寄存器**和**局部变量**，确保函数调用能正确返回且不破坏调用者的数据。

---

## 参考资料

- [RISC-V Calling Convention](https://github.com/riscv-non-isa/riscv-elf-psabi-doc)
- [RISC-V Assembly Programmer's Manual](https://github.com/riscv-non-isa/riscv-asm-manual)
- [Understanding Stack Frames](https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64)
